100  basic questions on data structures in Python will cover a wide array of topics, including arrays, lists, stacks, queues, linked lists, trees, graphs, hash tables, and more. Below are the questions.

### Arrays

1. Create an array of 5 elements and print it.
2. Access the third element in the array.
3. Change the value of the second element in the array to 10.
4. Find the length of the array.
5. Append a new element to the end of the array.
6. Remove the last element from the array.
7. Insert a new element at the second position in the array.
8. Remove the element at the second position in the array.
9. Find the index of the element with value 4 in the array.
10. Sort the array in ascending order.

### Lists

11. Create a list of 5 elements and print it.
12. Access the third element in the list.
13. Change the value of the second element in the list to 10.
14. Find the length of the list.
15. Append a new element to the end of the list.
16. Remove the last element from the list.
17. Insert a new element at the second position in the list.
18. Remove the element at the second position in the list.
19. Find the index of the element with value 4 in the list.
20. Sort the list in ascending order.

### Stacks

21. Implement a stack using a list.
22. Check if the stack is empty.
23. Get the top element of the stack without removing it.
24. Implement a function to push an element onto the stack.
25. Implement a function to pop an element from the stack.
26. Implement a function to get the top element of the stack.
27. Check if the stack is empty using a function.
28. Create a stack with a maximum size and check if it is full.
29. Implement a function to get the size of the stack.
30. Reverse a string using a stack.

### Queues

31. Implement a queue using a list.
32. Check if the queue is empty.
33. Get the front element of the queue without removing it.
34. Implement a function to enqueue an element into the queue.
35. Implement a function to dequeue an element from the queue.
36. Implement a function to get the front element of the queue.
37. Check if the queue is empty using a function.
38. Create a queue with a maximum size and check if it is full.
39. Implement a function to get the size of the queue.
40. Reverse a queue using a stack.

### Linked Lists

41. Create a node class for a singly linked list.
42. Create a singly linked list and print its elements.
43. Insert a new node at the beginning of a singly linked list.
44. Insert a new node at the end of a singly linked list.
45. Insert a new node after a given node in a singly linked list.
46. Delete a node from a singly linked list.
47. Search for a node in a singly linked list.
48. Reverse a singly linked list.
49. Find the middle of a singly linked list.
50. Check if a singly linked list has a loop.

### Trees

51. Create a Node class for a binary tree.
52. Insert a node into a binary tree.
53. Inorder traversal of a binary tree.
54. Preorder traversal of a binary tree.
55. Postorder traversal of a binary tree.
56. Level order traversal of a binary tree.
57. Find the height of a binary tree.
58. Count the number of nodes in a binary tree.
59. Find the minimum value in a binary search tree.
60. Find the maximum value in a binary search tree.

### Graphs

61. Create an adjacency list for an undirected graph.
62. Perform Breadth-First Search (BFS) on a graph.
63. Perform Depth-First Search (DFS) on a graph.
64. Detect a cycle in an undirected graph using DFS.
65. Detect a cycle in a directed graph using DFS.

### Hash Tables

66. Implement a hash table using chaining for collision resolution.
67. Implement a hash table using open addressing with linear probing for collision resolution.
68. Implement a hash table using open addressing with quadratic probing for collision resolution.
69. Implement a hash table using double hashing for collision resolution.

### Heaps

70. Implement a Min-Heap class.
71. Implement a Max-Heap class.
72. Heap Sort Algorithm.
73. Find the Kth smallest element in an array using a heap.
74. Merge K sorted lists using a heap.
75. Check if a binary tree is a heap.

### Tries

76. Implement a Trie class with insert and search methods.
77. Implement a Trie class with delete method.
78. Implement a Trie class with a method to find words with a given prefix.
79. Count the number of words in a Trie.

### Advanced Graph Algorithms
80. Find the shortest path between two nodes using Dijkstra's algorithm.
81. Find the shortest path between two nodes using Bellman-Ford algorithm.
82. Find the minimum spanning tree using Kruskal's algorithm.
83. Find the minimum spanning tree using Prim's algorithm.
84. Find all strongly connected components in a directed graph using Kosaraju's algorithm.
85. Find the shortest path between two nodes in an unweighted graph using Breadth-First Search (BFS).
86. Find the connected components in an undirected graph.
87. Check if a graph contains a cycle using Depth-First Search (DFS).
88. Find the longest path in a Directed Acyclic Graph (DAG).
89. Find all bridges in an undirected graph.
90. Find the number of connected components in a graph.
91. Implement a stack using a list.
92. Implement a queue using a list.
93. Implement a doubly linked list.
94. Implement a binary search tree (BST).
95. Check if a string is a palindrome.
96. Reverse a string.
97. Find the largest prime factor of a number.
98. Find the nth Fibonacci number.
99. Generate a list of prime numbers up to n using the Sieve of Eratosthenes.
100. Find the Greatest Common Divisor (GCD) of two numbers using the Euclidean algorithm.

