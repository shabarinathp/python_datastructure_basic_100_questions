100  basic questions on data structures in Python will cover a wide array of topics, including arrays, lists, stacks, queues, linked lists, trees, graphs, hash tables, and more. Below are the questions, along with their solutions.

### Arrays

1. **Create an array of 5 elements and print it.**
    ```python
    arr = [1, 2, 3, 4, 5]
    print(arr)
    ```

2. **Access the third element in the array.**
    ```python
    arr = [1, 2, 3, 4, 5]
    print(arr[2])
    ```

3. **Change the value of the second element in the array to 10.**
    ```python
    arr = [1, 2, 3, 4, 5]
    arr[1] = 10
    print(arr)
    ```

4. **Find the length of the array.**
    ```python
    arr = [1, 2, 3, 4, 5]
    print(len(arr))
    ```

5. **Append a new element to the end of the array.**
    ```python
    arr = [1, 2, 3, 4, 5]
    arr.append(6)
    print(arr)
    ```

6. **Remove the last element from the array.**
    ```python
    arr = [1, 2, 3, 4, 5]
    arr.pop()
    print(arr)
    ```

7. **Insert a new element at the second position in the array.**
    ```python
    arr = [1, 2, 3, 4, 5]
    arr.insert(1, 10)
    print(arr)
    ```

8. **Remove the element at the second position in the array.**
    ```python
    arr = [1, 2, 3, 4, 5]
    arr.pop(1)
    print(arr)
    ```

9. **Find the index of the element with value 4 in the array.**
    ```python
    arr = [1, 2, 3, 4, 5]
    print(arr.index(4))
    ```

10. **Sort the array in ascending order.**
    ```python
    arr = [5, 3, 1, 4, 2]
    arr.sort()
    print(arr)
    ```

### Lists

11. **Create a list of 5 elements and print it.**
    ```python
    lst = [1, 2, 3, 4, 5]
    print(lst)
    ```

12. **Access the third element in the list.**
    ```python
    lst = [1, 2, 3, 4, 5]
    print(lst[2])
    ```

13. **Change the value of the second element in the list to 10.**
    ```python
    lst = [1, 2, 3, 4, 5]
    lst[1] = 10
    print(lst)
    ```

14. **Find the length of the list.**
    ```python
    lst = [1, 2, 3, 4, 5]
    print(len(lst))
    ```

15. **Append a new element to the end of the list.**
    ```python
    lst = [1, 2, 3, 4, 5]
    lst.append(6)
    print(lst)
    ```

16. **Remove the last element from the list.**
    ```python
    lst = [1, 2, 3, 4, 5]
    lst.pop()
    print(lst)
    ```

17. **Insert a new element at the second position in the list.**
    ```python
    lst = [1, 2, 3, 4, 5]
    lst.insert(1, 10)
    print(lst)
    ```

18. **Remove the element at the second position in the list.**
    ```python
    lst = [1, 2, 3, 4, 5]
    lst.pop(1)
    print(lst)
    ```

19. **Find the index of the element with value 4 in the list.**
    ```python
    lst = [1, 2, 3, 4, 5]
    print(lst.index(4))
    ```

20. **Sort the list in ascending order.**
    ```python
    lst = [5, 3, 1, 4, 2]
    lst.sort()
    print(lst)
    ```

### Stacks

21. **Implement a stack using a list.**

    ```python
    stack = []

    # Push elements
    stack.append(1)
    stack.append(2)
    stack.append(3)

    # Pop elements
    print(stack.pop())
    print(stack.pop())
    print(stack.pop())
    ```

22. **Check if the stack is empty.**
    ```python
    stack = []
    print(len(stack) == 0)
    ```

23. **Get the top element of the stack without removing it.**
    ```python
    stack = [1, 2, 3]
    print(stack[-1])
    ```

24. **Implement a function to push an element onto the stack.**
    ```python
    stack = []
    
    def push(stack, element):
        stack.append(element)
        
    push(stack, 1)
    print(stack)
    ```

25. **Implement a function to pop an element from the stack.**
    ```python
    stack = [1, 2, 3]
    
    def pop(stack):
        if len(stack) == 0:
            return None
        return stack.pop()
        
    print(pop(stack))
    print(stack)
    ```

26. **Implement a function to get the top element of the stack.**
    ```python
    stack = [1, 2, 3]
    
    def top(stack):
        if len(stack) == 0:
            return None
        return stack[-1]
        
    print(top(stack))
    ```

27. **Check if the stack is empty using a function.**
    ```python
    stack = []
    
    def is_empty(stack):
        return len(stack) == 0
        
    print(is_empty(stack))
    ```

28. **Create a stack with a maximum size and check if it is full.**
    ```python
    stack = [1, 2, 3]
    max_size = 5
    
    def is_full(stack, max_size):
        return len(stack) == max_size
        
    print(is_full(stack, max_size))
    ```

29. **Implement a function to get the size of the stack.**
    ```python
    stack = [1, 2, 3]
    
    def size(stack):
        return len(stack)
        
    print(size(stack))
    ```

30. **Reverse a string using a stack.**
    ```python
    s = "hello"
    stack = list(s)
    reversed_string = ""
    while stack:
        reversed_string += stack.pop()
    print(reversed_string)
    ```

### Queues

31. **Implement a queue using a list.**
    ```python
    queue = []

    # Enqueue elements
    queue.append(1)
    queue.append(2)
    queue.append(3)

    # Dequeue elements
    print(queue.pop(0))
    print(queue.pop(0))
    print(queue.pop(0))
    ```

32. **Check if the queue is empty.**
    ```python
    queue = []
    print(len(queue) == 0)
    ```

33. **Get the front element of the queue without removing it.**
    ```python
    queue = [1, 2, 3]
    print(queue[0])
    ```

34. **Implement a function to enqueue an element into the queue.**
    ```python
    queue = []
    
    def enqueue(queue, element):
        queue.append(element)
        
    enqueue(queue, 1)
    print(queue)
    ```

35. **Implement a function to dequeue an element from the queue.**
    ```python
    queue = [1, 2, 3]
    
    def dequeue(queue):
        if len(queue) == 0:
            return None
        return queue.pop(0)
        
    print(dequeue(queue))
    print(queue)
    ```

36. **Implement a function to get the front element of the queue.**
    ```python
    queue = [1, 2, 3]
    
    def front(queue):
        if len(queue) == 0:
            return None
        return queue[0]
        
    print(front(queue))
    ```

37. **Check if the queue is empty using a function.**
    ```python
    queue = []
    
    def is_empty(queue):
        return len(queue) == 0
        
    print(is_empty(queue))
    ```

38. **Create a queue with a maximum size and check if it is full.**
    ```python
    queue = [1, 2, 3]
    max_size = 5
    
    def is_full(queue, max_size):
        return len(queue) == max_size
        
    print(is_full(queue, max_size))
    ```

39. **Implement a function to get the size of the queue.**
    ```python
    queue = [1, 2, 3]
    
    def size(queue):
       

 return len(queue)
        
    print(size(queue))
    ```

40. **Reverse a queue using a stack.**
    ```python
    queue = [1, 2, 3]
    stack = []
    while queue:
        stack.append(queue.pop(0))
    while stack:
        queue.append(stack.pop())
    print(queue)
    ```

### Linked Lists

41. **Create a node class for a singly linked list.**
    ```python
    class Node:
        def __init__(self, data):
            self.data = data
            self.next = None
    ```

42. **Create a singly linked list and print its elements.**
    ```python
    class Node:
        def __init__(self, data):
            self.data = data
            self.next = None

    class LinkedList:
        def __init__(self):
            self.head = None

        def print_list(self):
            current = self.head
            while current:
                print(current.data, end=" -> ")
                current = current.next
            print("None")

    # Create linked list
    ll = LinkedList()
    ll.head = Node(1)
    second = Node(2)
    third = Node(3)
    ll.head.next = second
    second.next = third

    ll.print_list()
    ```

43. **Insert a new node at the beginning of a singly linked list.**
    ```python
    class Node:
        def __init__(self, data):
            self.data = data
            self.next = None

    class LinkedList:
        def __init__(self):
            self.head = None

        def insert_at_beginning(self, new_data):
            new_node = Node(new_data)
            new_node.next = self.head
            self.head = new_node

        def print_list(self):
            current = self.head
            while current:
                print(current.data, end=" -> ")
                current = current.next
            print("None")

    # Create linked list and insert node
    ll = LinkedList()
    ll.insert_at_beginning(1)
    ll.insert_at_beginning(2)
    ll.insert_at_beginning(3)
    ll.print_list()
    ```

44. **Insert a new node at the end of a singly linked list.**
    ```python
    class Node:
        def __init__(self, data):
            self.data = data
            self.next = None

    class LinkedList:
        def __init__(self):
            self.head = None

        def insert_at_end(self, new_data):
            new_node = Node(new_data)
            if self.head is None:
                self.head = new_node
                return
            last = self.head
            while last.next:
                last = last.next
            last.next = new_node

        def print_list(self):
            current = self.head
            while current:
                print(current.data, end=" -> ")
                current = current.next
            print("None")

    # Create linked list and insert node
    ll = LinkedList()
    ll.insert_at_end(1)
    ll.insert_at_end(2)
    ll.insert_at_end(3)
    ll.print_list()
    ```

45. **Insert a new node after a given node in a singly linked list.**
    ```python
    class Node:
        def __init__(self, data):
            self.data = data
            self.next = None

    class LinkedList:
        def __init__(self):
            self.head = None

        def insert_after(self, prev_node, new_data):
            if prev_node is None:
                print("The given previous node must inLinkedList.")
                return
            new_node = Node(new_data)
            new_node.next = prev_node.next
            prev_node.next = new_node

        def print_list(self):
            current = self.head
            while current:
                print(current.data, end=" -> ")
                current = current.next
            print("None")

    # Create linked list and insert node
    ll = LinkedList()
    ll.head = Node(1)
    second = Node(2)
    third = Node(3)
    ll.head.next = second
    second.next = third

    ll.insert_after(second, 4)
    ll.print_list()
    ```

46. **Delete a node from a singly linked list.**
    ```python
    class Node:
        def __init__(self, data):
            self.data = data
            self.next = None

    class LinkedList:
        def __init__(self):
            self.head = None

        def delete_node(self, key):
            temp = self.head

            if temp is not None:
                if temp.data == key:
                    self.head = temp.next
                    temp = None
                    return

            while temp is not None:
                if temp.data == key:
                    break
                prev = temp
                temp = temp.next

            if temp == None:
                return

            prev.next = temp.next
            temp = None

        def print_list(self):
            current = self.head
            while current:
                print(current.data, end=" -> ")
                current = current.next
            print("None")

    # Create linked list and delete node
    ll = LinkedList()
    ll.head = Node(1)
    second = Node(2)
    third = Node(3)
    ll.head.next = second
    second.next = third

    ll.delete_node(2)
    ll.print_list()
    ```

47. **Search for a node in a singly linked list.**
    ```python
    class Node:
        def __init__(self, data):
            self.data = data
            self.next = None

    class LinkedList:
        def __init__(self):
            self.head = None

        def search(self, key):
            current = self.head
            while current:
                if current.data == key:
                    return True
                current = current.next
            return False

        def print_list(self):
            current = self.head
            while current:
                print(current.data, end=" -> ")
                current = current.next
            print("None")

    # Create linked list and search for node
    ll = LinkedList()
    ll.head = Node(1)
    second = Node(2)
    third = Node(3)
    ll.head.next = second
    second.next = third

    print(ll.search(2))
    print(ll.search(4))
    ```

48. **Reverse a singly linked list.**
    ```python
    class Node:
        def __init__(self, data):
            self.data = data
            self.next = None

    class LinkedList:
        def __init__(self):
            self.head = None

        def reverse(self):
            prev = None
            current = self.head
            while current is not None:
                next = current.next
                current.next = prev
                prev = current
                current = next
            self.head = prev

        def print_list(self):
            current = self.head
            while current:
                print(current.data, end=" -> ")
                current = current.next
            print("None")

    # Create linked list and reverse it
    ll = LinkedList()
    ll.head = Node(1)
    second = Node(2)
    third = Node(3)
    ll.head.next = second
    second.next = third

    ll.reverse()
    ll.print_list()
    ```

49. **Find the middle of a singly linked list.**
    ```python
    class Node:
        def __init__(self, data):
            self.data = data
            self.next = None

    class LinkedList:
        def __init__(self):
            self.head = None

        def find_middle(self):
            slow_ptr = self.head
            fast_ptr = self.head
            if self.head is not None:
                while fast_ptr is not None and fast_ptr.next is not None:
                    fast_ptr = fast_ptr.next.next
                    slow_ptr = slow_ptr.next
                print("The middle element is", slow_ptr.data)

        def print_list(self):
            current = self.head
            while current:
                print(current.data, end=" -> ")
                current = current.next
            print("None")

    # Create linked list and find middle
    ll = LinkedList()
    ll.head = Node(1)
    second = Node(2)
    third = Node(3)
    fourth = Node(4)
    ll.head.next = second
    second.next = third
    third.next = fourth

    ll.find_middle()
    ```

50. **Check if a singly linked list has a loop.**
    ```python
    class Node:
        def __init__(self, data):
            self.data = data
            self.next = None

    class LinkedList:
        def __init__(self):
            self.head = None

        def detect_loop(self):
            slow_ptr = self.head
            fast_ptr = self.head
            while slow_ptr and fast_ptr and fast_ptr.next:
                slow_ptr = slow_ptr.next
                fast_ptr = fast_ptr.next.next
                if slow_ptr == fast_ptr:
                    return True
            return False

        def print_list(self):
            current = self.head
            while current:
                print(current.data, end=" -> ")
                current = current.next
            print("None")

    # Create linked list with a loop and detect it
    ll = LinkedList()
    ll.head = Node(1)
    second = Node(2)
    third = Node(3)
    fourth = Node(4)
    ll.head.next = second
    second.next = third
    third.next = fourth
    fourth.next = second  # Creating a loop

    print(ll.detect_loop())
    ```


### Trees

51. **Create a Node class for a binary tree.**
    ```python
    class Node:
        def __init__(self, key):
            self.left = None
            self.right = None
            self.val = key
    ```

52. **Insert a node into a binary tree.**
    ```python
    class Node:
        def __init__(self, key):
            self.left = None
            self.right = None
            self.val = key

    def insert(root, key):
        if root is None:
            return Node(key)
        else:
            if root.val < key:
                root.right = insert(root.right, key)
            else:
                root.left = insert(root.left, key)
        return root

    # Create the root
    root = Node(50)
    insert(root, 30)
    insert(root, 20)
    insert(root, 40)
    insert(root, 70)
    insert(root, 60)
    insert(root, 80)
    ```

53. **Inorder traversal of a binary tree.**
    ```python
    class Node:
        def __init__(self, key):
            self.left = None
            self.right = None
            self.val = key

    def inorder(root):
        if root:
            inorder(root.left)
            print(root.val, end=" ")
            inorder(root.right)

    # Create the root
    root = Node(1)
    root.left = Node(2)
    root.right = Node(3)
    root.left.left = Node(4)
    root.left.right = Node(5)

    inorder(root)
    ```

54. **Preorder traversal of a binary tree.**
    ```python
    class Node:
        def __init__(self, key):
            self.left = None
            self.right = None
            self.val = key

    def preorder(root):
        if root:
            print(root.val, end=" ")
            preorder(root.left)
            preorder(root.right)

    # Create the root
    root = Node(1)
    root.left = Node(2)
    root.right = Node(3)
    root.left.left = Node(4)
    root.left.right = Node(5)

    preorder(root)
    ```

55. **Postorder traversal of a binary tree.**
    ```python
    class Node:
        def __init__(self, key):
            self.left = None
            self.right = None
            self.val = key

    def postorder(root):
        if root:
            postorder(root.left)
            postorder(root.right)
            print(root.val, end=" ")

    # Create the root
    root = Node(1)
    root.left = Node(2)
    root.right = Node(3)
    root.left.left = Node(4)
    root.left.right = Node(5)

    postorder(root)
    ```

56. **Level order traversal of a binary tree.**
    ```python
    class Node:
        def __init__(self, key):
            self.left = None
            self.right = None
            self.val = key

    def level_order(root):
        if root is None:
            return
        
        queue = []
        queue.append(root)

        while queue:
            node = queue.pop(0)
            print(node.val, end=" ")

            if node.left:
                queue.append(node.left)

            if node.right:
                queue.append(node.right)

    # Create the root
    root = Node(1)
    root.left = Node(2)
    root.right = Node(3)
    root.left.left = Node(4)
    root.left.right = Node(5)

    level_order(root)
    ```

57. **Find the height of a binary tree.**
    ```python
    class Node:
        def __init__(self, key):
            self.left = None
            self.right = None
            self.val = key

    def height(node):
        if node is None:
            return 0
        else:
            l_height = height(node.left)
            r_height = height(node.right)

            if l_height > r_height:
                return l_height + 1
            else:
                return r_height + 1

    # Create the root
    root = Node(1)
    root.left = Node(2)
    root.right = Node(3)
    root.left.left = Node(4)
    root.left.right = Node(5)

    print(height(root))
    ```

58. **Count the number of nodes in a binary tree.**
    ```python
    class Node:
        def __init__(self, key):
            self.left = None
            self.right = None
            self.val = key

    def count_nodes(root):
        if root is None:
            return 0
        return 1 + count_nodes(root.left) + count_nodes(root.right)

    # Create the root
    root = Node(1)
    root.left = Node(2)
    root.right = Node(3)
    root.left.left = Node(4)
    root.left.right = Node(5)

    print(count_nodes(root))
    ```

59. **Find the minimum value in a binary search tree.**
    ```python
    class Node:
        def __init__(self, key):
            self.left = None
            self.right = None
            self.val = key

    def min_value_node(node):
        current = node

        while current.left is not None:
            current = current.left

        return current

    # Create the root
    root = Node(50)
    root.left = Node(30)
    root.right = Node(70)
    root.left.left = Node(20)
    root.left.right = Node(40)
    root.right.left = Node(60)
    root.right.right = Node(80)

    print(min_value_node(root).val)
    ```

60. **Find the maximum value in a binary search tree.**
    ```python
    class Node:
        def __init__(self, key):
            self.left = None
            self.right = None
            self.val = key

    def max_value_node(node):
        current = node

        while current.right is not None:
            current = current.right

        return current

    # Create the root
    root = Node(50)
    root.left = Node(30)
    root.right = Node(70)
    root.left.left = Node(20)
    root.left.right = Node(40)
    root.right.left = Node(60)
    root.right.right = Node(80)

    print(max_value_node(root).val)
    ```

### Graphs

61. **Create an adjacency list for an undirected graph.**
    ```python
    from collections import defaultdict

    class Graph:
        def __init__(self):
            self.graph = defaultdict(list)

        def add_edge(self, u, v):
            self.graph[u].append(v)
            self.graph[v].append(u)

        def print_graph(self):
            for node in self.graph:
                print(node, "->", self.graph[node])

    g = Graph()
    g.add_edge(0, 1)
    g.add_edge(0, 4)
    g.add_edge(1, 2)
    g.add_edge(1, 3)
    g.add_edge(1, 4)
    g.add_edge(2, 3)
    g.add_edge(3, 4)

    g.print_graph()
    ```

62. **Perform Breadth-First Search (BFS) on a graph.**
    ```python
    from collections import defaultdict, deque

    class Graph:
        def __init__(self):
            self.graph = defaultdict(list)

        def add_edge(self, u, v):
            self.graph[u].append(v)

        def bfs(self, start):
            visited = set()
            queue = deque([start])

            while queue:
                node = queue.popleft()
                if node not in visited:
                    print(node, end=" ")
                    visited.add(node)
                    for neighbor in self.graph[node]:
                        if neighbor not in visited:
                            queue.append(neighbor)

    g = Graph()
    g.add_edge(0, 1)
    g.add_edge(0, 2)
    g.add_edge(1, 2)
    g.add_edge(2, 0)
    g.add_edge(2, 3)
    g.add_edge(3, 3)

    g.bfs(2)
    ```

63. **Perform Depth-First Search (DFS) on a graph.**
    ```python
    from collections import defaultdict

    class Graph:
        def __init__(self):
            self.graph = defaultdict(list)

        def add_edge(self, u, v):
            self.graph[u].append(v)

        def dfs_util(self, v, visited):
            visited.add(v)
            print(v, end=" ")

            for neighbor in self.graph[v]:
                if neighbor not in visited:
                    self.dfs_util(neighbor, visited)

        def dfs(self, start):
            visited = set()
            self.dfs_util(start, visited)

    g = Graph()
    g.add_edge(0, 1)
    g.add_edge(0, 2)
    g.add_edge(1, 2)
    g.add_edge(2, 0)
    g.add_edge(2, 3)
    g.add_edge(3, 3)

    g.dfs(2)
    ```

64. **Detect a cycle in an undirected graph using DFS.**
    ```python
    from collections import defaultdict

    class Graph:
        def __init__(self):
            self.graph = defaultdict(list)

        def add_edge(self, u,

 v):
            self.graph[u].append(v)
            self.graph[v].append(u)

        def is_cyclic_util(self, v, visited, parent):
            visited[v] = True

            for neighbor in self.graph[v]:
                if not visited[neighbor]:
                    if self.is_cyclic_util(neighbor, visited, v):
                        return True
                elif parent != neighbor:
                    return True

            return False

        def is_cyclic(self):
            visited = [False] * (len(self.graph))

            for i in range(len(self.graph)):
                if not visited[i]:
                    if self.is_cyclic_util(i, visited, -1):
                        return True

            return False

    g = Graph()
    g.add_edge(0, 1)
    g.add_edge(1, 2)
    g.add_edge(2, 0)

    if g.is_cyclic():
        print("Graph contains cycle")
    else:
        print("Graph does not contain cycle")
    ```

65. **Detect a cycle in a directed graph using DFS.**
    ```python
    from collections import defaultdict

    class Graph:
        def __init__(self):
            self.graph = defaultdict(list)

        def add_edge(self, u, v):
            self.graph[u].append(v)

        def is_cyclic_util(self, v, visited, rec_stack):
            visited[v] = True
            rec_stack[v] = True

            for neighbor in self.graph[v]:
                if not visited[neighbor]:
                    if self.is_cyclic_util(neighbor, visited, rec_stack):
                        return True
                elif rec_stack[neighbor]:
                    return True

            rec_stack[v] = False
            return False

        def is_cyclic(self):
            visited = [False] * (len(self.graph))
            rec_stack = [False] * (len(self.graph))

            for node in range(len(self.graph)):
                if not visited[node]:
                    if self.is_cyclic_util(node, visited, rec_stack):
                        return True

            return False

    g = Graph()
    g.add_edge(0, 1)
    g.add_edge(1, 2)
    g.add_edge(2, 0)

    if g.is_cyclic():
        print("Graph contains cycle")
    else:
        print("Graph does not contain cycle")
    ```

### Hash Tables

66. **Implement a hash table using chaining for collision resolution.**
    ```python
    class HashTable:
        def __init__(self):
            self.table = [[] for _ in range(10)]

        def hash_function(self, key):
            return key % len(self.table)

        def insert(self, key, value):
            hash_key = self.hash_function(key)
            key_exists = False
            bucket = self.table[hash_key]
            for i, kv in enumerate(bucket):
                k, v = kv
                if key == k:
                    key_exists = True
                    break
            if key_exists:
                bucket[i] = (key, value)
            else:
                bucket.append((key, value))

        def get(self, key):
            hash_key = self.hash_function(key)
            bucket = self.table[hash_key]
            for k, v in bucket:
                if k == key:
                    return v
            return None

        def delete(self, key):
            hash_key = self.hash_function(key)
            bucket = self.table[hash_key]
            for i, kv in enumerate(bucket):
                k, v = kv
                if k == key:
                    del bucket[i]
                    return True
            return False

    h = HashTable()
    h.insert(1, 'one')
    h.insert(2, 'two')
    h.insert(3, 'three')
    print(h.get(2))
    h.delete(2)
    print(h.get(2))
    ```

67. **Implement a hash table using open addressing with linear probing for collision resolution.**
    ```python
    class HashTable:
        def __init__(self):
            self.size = 10
            self.table = [None] * self.size

        def hash_function(self, key):
            return key % self.size

        def insert(self, key, value):
            hash_key = self.hash_function(key)
            while self.table[hash_key] is not None:
                hash_key = (hash_key + 1) % self.size
            self.table[hash_key] = (key, value)

        def get(self, key):
            hash_key = self.hash_function(key)
            while self.table[hash_key] is not None:
                k, v = self.table[hash_key]
                if k == key:
                    return v
                hash_key = (hash_key + 1) % self.size
            return None

        def delete(self, key):
            hash_key = self.hash_function(key)
            while self.table[hash_key] is not None:
                k, v = self.table[hash_key]
                if k == key:
                    self.table[hash_key] = None
                    return True
                hash_key = (hash_key + 1) % self.size
            return False

    h = HashTable()
    h.insert(1, 'one')
    h.insert(2, 'two')
    h.insert(3, 'three')
    print(h.get(2))
    h.delete(2)
    print(h.get(2))
    ```

68. **Implement a hash table using open addressing with quadratic probing for collision resolution.**
    ```python
    class HashTable:
        def __init__(self):
            self.size = 10
            self.table = [None] * self.size

        def hash_function(self, key):
            return key % self.size

        def insert(self, key, value):
            hash_key = self.hash_function(key)
            i = 1
            while self.table[hash_key] is not None:
                hash_key = (hash_key + i**2) % self.size
                i += 1
            self.table[hash_key] = (key, value)

        def get(self, key):
            hash_key = self.hash_function(key)
            i = 1
            while self.table[hash_key] is not None:
                k, v = self.table[hash_key]
                if k == key:
                    return v
                hash_key = (hash_key + i**2) % self.size
                i += 1
            return None

        def delete(self, key):
            hash_key = self.hash_function(key)
            i = 1
            while self.table[hash_key] is not None:
                k, v = self.table[hash_key]
                if k == key:
                    self.table[hash_key] = None
                    return True
                hash_key = (hash_key + i**2) % self.size
                i += 1
            return False

    h = HashTable()
    h.insert(1, 'one')
    h.insert(2, 'two')
    h.insert(3, 'three')
    print(h.get(2))
    h.delete(2)
    print(h.get(2))
    ```

69. **Implement a hash table using double hashing for collision resolution.**
    ```python
    class HashTable:
        def __init__(self):
            self.size = 10
            self.table = [None] * self.size

        def hash_function1(self, key):
            return key % self.size

        def hash_function2(self, key):
            return 7 - (key % 7)

        def insert(self, key, value):
            hash_key = self.hash_function1(key)
            step_size = self.hash_function2(key)
            while self.table[hash_key] is not None:
                hash_key = (hash_key + step_size) % self.size
            self.table[hash_key] = (key, value)

        def get(self, key):
            hash_key = self.hash_function1(key)
            step_size = self.hash_function2(key)
            while self.table[hash_key] is not None:
                k, v = self.table[hash_key]
                if k == key:
                    return v
                hash_key = (hash_key + step_size) % self.size
            return None

        def delete(self, key):
            hash_key = self.hash_function1(key)
            step_size = self.hash_function2(key)
            while self.table[hash_key] is not None:
                k, v = self.table[hash_key]
                if k == key:
                    self.table[hash_key] = None
                    return True
                hash_key = (hash_key + step_size) % self.size
            return False

    h = HashTable()
    h.insert(1, 'one')
    h.insert(2, 'two')
    h.insert(3, 'three')
    print(h.get(2))
    h.delete(2)
    print(h.get(2))
    ```

### Heaps

70. **Implement a Min-Heap class.**

    ```python
    class MinHeap:
        def __init__(self):
            self.heap = []

        def insert(self, val):
            self.heap.append(val)
            self._heapify_up(len(self.heap) - 1)

        def _heapify_up(self, index):
            parent_index = (index - 1) // 2
            if index > 0 and self.heap[index] < self.heap[parent_index]:
                self.heap[index], self.heap[parent_index] = self.heap[parent_index], self.heap[index]
                self._heapify_up(parent_index)

        def extract_min(self):
            if len(self.heap) == 0:
                raise IndexError("Heap is empty")
            min_val = self.heap[0]
            self.heap[0] = self.heap.pop()
            self._heapify_down(0)
            return min_val

        def _heapify_down(self, index):
            left_child = 2 * index + 1
            right_child = 2 * index + 2
            smallest = index

            if left_child < len(self.heap) and self.heap[left_child] < self.heap[smallest]:
                smallest = left_child
            if right_child < len(self.heap) and self.heap[right_child] < self.heap[smallest]:
                smallest = right_child
            if smallest != index:
                self.heap[index], self.heap[smallest] = self.heap[smallest], self.heap[index]
                self._heapify_down(smallest)

        def peek(self):
            if len(self.heap) == 0:
                raise IndexError("Heap is empty")
            return self.heap[0]

    # Example usage
    heap = MinHeap()
    heap.insert(10)
    heap.insert(20)
    heap.insert(5)
    heap.insert(30)
    print(heap.peek())  # Output: 5
    print(heap.extract_min())  # Output: 5
    ```

71. **Implement a Max-Heap class.**

    ```python
    class MaxHeap:
        def __init__(self):
            self.heap = []

        def insert(self, val):
            self.heap.append(val)
            self._heapify_up(len(self.heap) - 1)

        def _heapify_up(self, index):
            parent_index = (index - 1) // 2
            if index > 0 and self.heap[index] > self.heap[parent_index]:
                self.heap[index], self.heap[parent_index] = self.heap[parent_index], self.heap[index]
                self._heapify_up(parent_index)

        def extract_max(self):
            if len(self.heap) == 0:
                raise IndexError("Heap is empty")
            max_val = self.heap[0]
            self.heap[0] = self.heap.pop()
            self._heapify_down(0)
            return max_val

        def _heapify_down(self, index):
            left_child = 2 * index + 1
            right_child = 2 * index + 2
            largest = index

            if left_child < len(self.heap) and self.heap[left_child] > self.heap[largest]:
                largest = left_child
            if right_child < len(self.heap) and self.heap[right_child] > self.heap[largest]:
                largest = right_child
            if largest != index:
                self.heap[index], self.heap[largest] = self.heap[largest], self.heap[index]
                self._heapify_down(largest)

        def peek(self):
            if len(self.heap) == 0:
                raise IndexError("Heap is empty")
            return self.heap[0]

    # Example usage
    heap = MaxHeap()
    heap.insert(10)
    heap.insert(20)
    heap.insert(5)
    heap.insert(30)
    print(heap.peek())  # Output: 30
    print(heap.extract_max())  # Output: 30
    ```

72. **Heap Sort Algorithm.**

    ```python
    def heapify(arr, n, i):
        largest = i
        left_child = 2 * i + 1
        right_child = 2 * i + 2

        if left_child < n and arr[left_child] > arr[largest]:
            largest = left_child
        if right_child < n and arr[right_child] > arr[largest]:
            largest = right_child
        if largest != i:
            arr[i], arr[largest] = arr[largest], arr[i]
            heapify(arr, n, largest)

    def heap_sort(arr):
        n = len(arr)
        for i in range(n // 2 - 1, -1, -1):
            heapify(arr, n, i)
        for i in range(n-1, 0, -1):
            arr[i], arr[0] = arr[0], arr[i]
            heapify(arr, i, 0)

    arr = [12, 11, 13, 5, 6, 7]
    heap_sort(arr)
    print(arr)  # Output: [5, 6, 7, 11, 12, 13]
    ```

73. **Find the Kth smallest element in an array using a heap.**

    ```python
    import heapq

    def kth_smallest_element(arr, k):
        heapq.heapify(arr)
        for _ in range(k - 1):
            heapq.heappop(arr)
        return heapq.heappop(arr)

    arr = [7, 10, 4, 3, 20, 15]
    k = 3
    print(kth_smallest_element(arr, k))  # Output: 7
    ```

74. **Merge K sorted lists using a heap.**

    ```python
    import heapq

    def merge_k_lists(lists):
        min_heap = []
        for i, l in enumerate(lists):
            if l:
                heapq.heappush(min_heap, (l[0], i, 0))

        result = []
        while min_heap:
            val, list_idx, element_idx = heapq.heappop(min_heap)
            result.append(val)
            if element_idx + 1 < len(lists[list_idx]):
                next_val = lists[list_idx][element_idx + 1]
                heapq.heappush(min_heap, (next_val, list_idx, element_idx + 1))
        return result

    lists = [[1, 4, 5], [1, 3, 4], [2, 6]]
    print(merge_k_lists(lists))  # Output: [1, 1, 2, 3, 4, 4, 5, 6]
    ```

75. **Check if a binary tree is a heap.**

    ```python
    class Node:
        def __init__(self, key):
            self.left = None
            self.right = None
            self.val = key

    def is_heap(root):
        def count_nodes(node):
            if not node:
                return 0
            return 1 + count_nodes(node.left) + count_nodes(node.right)

        def is_complete_tree(node, index, number_nodes):
            if node is None:
                return True
            if index >= number_nodes:
                return False
            return (is_complete_tree(node.left, 2 * index + 1, number_nodes) and
                    is_complete_tree(node.right, 2 * index + 2, number_nodes))

        def is_heap_util(node):
            if node.left is None and node.right is None:
                return True
            if node.right is None:
                return node.val >= node.left.val
            if node.left is not None and node.right is not None:
                left = node.left.val
                right = node.right.val
                return (node.val >= left and node.val >= right and
                        is_heap_util(node.left) and is_heap_util(node.right))
            return False

        number_nodes = count_nodes(root)
        if is_complete_tree(root, 0, number_nodes):
            return is_heap_util(root)
        return False

    root = Node(10)
    root.left = Node(9)
    root.right = Node(8)
    root.left.left = Node(7)
    root.left.right = Node(6)
    root.right.left = Node(5)
    root.right.right = Node(4)

    print(is_heap(root))  # Output: True (since it is a valid Max-Heap)
    ```

### Tries

76. **Implement a Trie class with insert and search methods.**

    ```python
    class TrieNode:
        def __init__(self):
            self.children = {}
            self.is_end_of_word = False

    class Trie:
        def __init__(self):
            self.root = TrieNode()

        def insert(self, word):
            node = self.root
            for char in word:
                if char not in node.children:
                    node.children[char] = TrieNode()
                node = node.children[char]
            node.is_end_of_word = True

        def search(self, word):
            node = self.root
            for char in word:
                if char not in node.children:
                    return False
                node = node.children[char]
            return node.is_end_of_word

        def starts_with(self, prefix):
            node = self.root
            for char in prefix:
                if char not in node.children:
                    return False
                node = node.children[char]
            return True

    trie = Trie()


    trie.insert("apple")
    print(trie.search("apple"))  # Output: True
    print(trie.search("app"))    # Output: False
    print(trie.starts_with("app"))  # Output: True
    ```

77. **Implement a Trie class with delete method.**

    ```python
    class TrieNode:
        def __init__(self):
            self.children = {}
            self.is_end_of_word = False

    class Trie:
        def __init__(self):
            self.root = TrieNode()

        def insert(self, word):
            node = self.root
            for char in word:
                if char not in node.children:
                    node.children[char] = TrieNode()
                node = node.children[char]
            node.is_end_of_word = True

        def search(self, word):
            node = self.root
            for char in word:
                if char not in node.children:
                    return False
                node = node.children[char]
            return node.is_end_of_word

        def starts_with(self, prefix):
            node = self.root
            for char in prefix:
                if char not in node.children:
                    return False
                node = node.children[char]
            return True

        def delete(self, word):
            def _delete(node, word, index):
                if index == len(word):
                    if not node.is_end_of_word:
                        return False
                    node.is_end_of_word = False
                    return len(node.children) == 0
                char = word[index]
                if char not in node.children:
                    return False
                can_delete_child = _delete(node.children[char], word, index + 1)
                if can_delete_child:
                    del node.children[char]
                    return not node.is_end_of_word and len(node.children) == 0
                return False

            _delete(self.root, word, 0)

    trie = Trie()
    trie.insert("apple")
    trie.delete("apple")
    print(trie.search("apple"))  # Output: False
    ```

78. **Implement a Trie class with a method to find words with a given prefix.**

    ```python
    class TrieNode:
        def __init__(self):
            self.children = {}
            self.is_end_of_word = False

    class Trie:
        def __init__(self):
            self.root = TrieNode()

        def insert(self, word):
            node = self.root
            for char in word:
                if char not in node.children:
                    node.children[char] = TrieNode()
                node = node.children[char]
            node.is_end_of_word = True

        def search(self, word):
            node = self.root
            for char in word:
                if char not in node.children:
                    return False
                node = node.children[char]
            return node.is_end_of_word

        def starts_with(self, prefix):
            node = self.root
            for char in prefix:
                if char not in node.children:
                    return False
                node = node.children[char]
            return True

        def find_words_with_prefix(self, prefix):
            def _find_words(node, prefix, words):
                if node.is_end_of_word:
                    words.append(prefix)
                for char, child in node.children.items():
                    _find_words(child, prefix + char, words)

            node = self.root
            for char in prefix:
                if char not in node.children:
                    return []
                node = node.children[char]
            words = []
            _find_words(node, prefix, words)
            return words

    trie = Trie()
    trie.insert("apple")
    trie.insert("app")
    trie.insert("applet")
    print(trie.find_words_with_prefix("app"))  # Output: ['apple', 'app', 'applet']
    ```

79. **Count the number of words in a Trie.**

    ```python
    class TrieNode:
        def __init__(self):
            self.children = {}
            self.is_end_of_word = False

    class Trie:
        def __init__(self):
            self.root = TrieNode()
            self.word_count = 0

        def insert(self, word):
            node = self.root
            for char in word:
                if char not in node.children:
                    node.children[char] = TrieNode()
                node = node.children[char]
            if not node.is_end_of_word:
                node.is_end_of_word = True
                self.word_count += 1

        def count_words(self):
            return self.word_count

    trie = Trie()
    trie.insert("apple")
    trie.insert("app")
    print(trie.count_words())  # Output: 2
    ```

### Advanced Graph Algorithms

80. **Find the shortest path between two nodes using Dijkstra's algorithm.**

    ```python
    import heapq

    def dijkstra(graph, start, end):
        pq = [(0, start)]
        distances = {node: float('inf') for node in graph}
        distances[start] = 0

        while pq:
            current_dist, current_node = heapq.heappop(pq)

            if current_node == end:
                return current_dist

            if current_dist > distances[current_node]:
                continue

            for neighbor, weight in graph[current_node]:
                distance = current_dist + weight
                if distance < distances[neighbor]:
                    distances[neighbor] = distance
                    heapq.heappush(pq, (distance, neighbor))
        return float('inf')

    graph = {
        'A': [('B', 1), ('C', 4)],
        'B': [('A', 1), ('C', 2), ('D', 5)],
        'C': [('A', 4), ('B', 2), ('D', 1)],
        'D': [('B', 5), ('C', 1)]
    }

    print(dijkstra(graph, 'A', 'D'))  # Output: 3
    ```

81. **Find the shortest path between two nodes using Bellman-Ford algorithm.**

    ```python
    def bellman_ford(graph, start, end):
        distances = {node: float('inf') for node in graph}
        distances[start] = 0

        for _ in range(len(graph) - 1):
            for u in graph:
                for v, weight in graph[u]:
                    if distances[u] + weight < distances[v]:
                        distances[v] = distances[u] + weight

        return distances[end]

    graph = {
        'A': [('B', 1), ('C', 4)],
        'B': [('C', 2), ('D', 5)],
        'C': [('D', 1)],
        'D': []
    }

    print(bellman_ford(graph, 'A', 'D'))  # Output: 3
    ```

82. **Find the minimum spanning tree using Kruskal's algorithm.**

    ```python
    class DisjointSet:
        def __init__(self, n):
            self.parent = list(range(n))
            self.rank = [0] * n

        def find(self, x):
            if self.parent[x] != x:
                self.parent[x] = self.find(self.parent[x])
            return self.parent[x]

        def union(self, x, y):
            rootX = self.find(x)
            rootY = self.find(y)
            if rootX != rootY:
                if self.rank[rootX] > self.rank[rootY]:
                    self.parent[rootY] = rootX
                elif self.rank[rootX] < self.rank[rootY]:
                    self.parent[rootX] = rootY
                else:
                    self.parent[rootY] = rootX
                    self.rank[rootX] += 1

    def kruskal(graph):
        edges = []
        for u in graph:
            for v, weight in graph[u]:
                edges.append((weight, u, v))

        edges.sort()
        ds = DisjointSet(len(graph))
        mst = []
        total_weight = 0

        for weight, u, v in edges:
            if ds.find(u) != ds.find(v):
                ds.union(u, v)
                mst.append((u, v, weight))
                total_weight += weight

        return mst, total_weight

    graph = {
        0: [(1, 10), (2, 6), (3, 5)],
        1: [(0, 10), (2, 15)],
        2: [(0, 6), (1, 15), (3, 4)],
        3: [(0, 5), (2, 4)]
    }

    mst, total_weight = kruskal(graph)
    print(mst)  # Output: [(0, 3, 5), (2, 3, 4), (0, 2, 6), (1, 2, 15)]
    print(total_weight)  # Output: 30
    ```

83. **Find the minimum spanning tree using Prim's algorithm.**

    ```python
    import heapq

    def prim(graph):
        start_node = list(graph.keys())[0]
        visited = set()
        min_heap = [(0, start_node)]
        total_weight = 0
        mst = []

        while min_heap:
            weight, node = heapq.heappop(min_heap)
            if node in visited:
                continue
            visited.add(node)
            total_weight += weight
            for next_node, edge_weight in graph[node]:
                if next_node not in visited:
                    heapq.heappush(min_heap, (edge_weight, next_node))
                    mst.append((node, next_node, edge_weight))



        return mst, total_weight

    graph = {
        0: [(1, 10), (2, 6), (3, 5)],
        1: [(0, 10), (2, 15)],
        2: [(0, 6), (1, 15), (3, 4)],
        3: [(0, 5), (2, 4)]
    }

    mst, total_weight = prim(graph)
    print(mst)  # Output: [(0, 3, 5), (3, 2, 4), (2, 0, 6)]
    print(total_weight)  # Output: 15
    ```

84. **Find all strongly connected components in a directed graph using Kosaraju's algorithm.**

    ```python
    from collections import defaultdict, deque

    def kosaraju(graph):
        def dfs(v):
            visited.add(v)
            for neighbor in graph[v]:
                if neighbor not in visited:
                    dfs(neighbor)
            stack.append(v)

        def reverse_dfs(v, component):
            visited.add(v)
            component.append(v)
            for neighbor in reverse_graph[v]:
                if neighbor not in visited:
                    reverse_dfs(neighbor, component)

        stack = []
        visited = set()
        for node in graph:
            if node not in visited:
                dfs(node)

        reverse_graph = defaultdict(list)
        for u in graph:
            for v in graph[u]:
                reverse_graph[v].append(u)

        visited = set()
        sccs = []
        while stack:
            node = stack.pop()
            if node not in visited:
                component = []
                reverse_dfs(node, component)
                sccs.append(component)

        return sccs

    graph = {
        0: [1],
        1: [2],
        2: [0, 3],
        3: [4],
        4: [5],
        5: [3]
    }

    sccs = kosaraju(graph)
    print(sccs)  # Output: [[5, 3, 4], [2, 1, 0]]
    ```

85. **Find the shortest path between two nodes in an unweighted graph using Breadth-First Search (BFS).**

    ```python
    from collections import deque

    def bfs_shortest_path(graph, start, end):
        queue = deque([(start, [start])])
        visited = set()

        while queue:
            node, path = queue.popleft()
            if node == end:
                return path

            visited.add(node)
            for neighbor in graph[node]:
                if neighbor not in visited:
                    queue.append((neighbor, path + [neighbor]))

        return None

    graph = {
        'A': ['B', 'C'],
        'B': ['A', 'D', 'E'],
        'C': ['A', 'F'],
        'D': ['B'],
        'E': ['B', 'F'],
        'F': ['C', 'E']
    }

    print(bfs_shortest_path(graph, 'A', 'F'))  # Output: ['A', 'C', 'F']
    ```

86. **Find the connected components in an undirected graph.**

    ```python
    def connected_components(graph):
        def dfs(node, component):
            stack = [node]
            while stack:
                v = stack.pop()
                if v not in visited:
                    visited.add(v)
                    component.append(v)
                    for neighbor in graph[v]:
                        if neighbor not in visited:
                            stack.append(neighbor)

        visited = set()
        components = []
        for node in graph:
            if node not in visited:
                component = []
                dfs(node, component)
                components.append(component)

        return components

    graph = {
        0: [1, 2],
        1: [0],
        2: [0],
        3: [4],
        4: [3],
        5: []
    }

    print(connected_components(graph))  # Output: [[0, 1, 2], [3, 4], [5]]
    ```

87. **Check if a graph contains a cycle using Depth-First Search (DFS).**

    ```python
    def has_cycle(graph):
        def dfs(v, parent):
            visited.add(v)
            for neighbor in graph[v]:
                if neighbor not in visited:
                    if dfs(neighbor, v):
                        return True
                elif parent != neighbor:
                    return True
            return False

        visited = set()
        for node in graph:
            if node not in visited:
                if dfs(node, None):
                    return True
        return False

    graph = {
        0: [1],
        1: [0, 2],
        2: [1, 3],
        3: [2, 4],
        4: [3, 5],
        5: [4]
    }

    print(has_cycle(graph))  # Output: False
    ```

88. **Find the longest path in a Directed Acyclic Graph (DAG).**

    ```python
    from collections import defaultdict, deque

    def longest_path_dag(graph):
        def topological_sort():
            indegree = {u: 0 for u in graph}
            for u in graph:
                for v in graph[u]:
                    indegree[v] += 1

            queue = deque([u for u in graph if indegree[u] == 0])
            topo_order = []

            while queue:
                u = queue.popleft()
                topo_order.append(u)
                for v in graph[u]:
                    indegree[v] -= 1
                    if indegree[v] == 0:
                        queue.append(v)

            return topo_order

        topo_order = topological_sort()
        distances = {u: float('-inf') for u in graph}
        distances[topo_order[0]] = 0

        for u in topo_order:
            for v in graph[u]:
                if distances[u] + 1 > distances[v]:
                    distances[v] = distances[u] + 1

        return max(distances.values())

    graph = {
        0: [1, 2],
        1: [2],
        2: [3],
        3: [4],
        4: []
    }

    print(longest_path_dag(graph))  # Output: 4
    ```

89. **Find all bridges in an undirected graph.**

    ```python
    def find_bridges(graph):
        def dfs(u, parent):
            nonlocal time
            visited[u] = True
            discovery[u] = low[u] = time
            time += 1

            for v in graph[u]:
                if not visited[v]:
                    dfs(v, u)
                    low[u] = min(low[u], low[v])
                    if low[v] > discovery[u]:
                        bridges.append((u, v))
                elif v != parent:
                    low[u] = min(low[u], discovery[v])

        visited = {u: False for u in graph}
        discovery = {}
        low = {}
        time = 0
        bridges = []

        for u in graph:
            if not visited[u]:
                dfs(u, None)

        return bridges

    graph = {
        0: [1, 2],
        1: [0, 2],
        2: [0, 1, 3],
        3: [2, 4],
        4: [3]
    }

    print(find_bridges(graph))  # Output: [(2, 3)]
    ```

90. **Find the number of connected components in a graph.**

    ```python
    def count_connected_components(graph):
        def dfs(node):
            stack = [node]
            while stack:
                v = stack.pop()
                if v not in visited:
                    visited.add(v)
                    for neighbor in graph[v]:
                        if neighbor not in visited:
                            stack.append(neighbor)

        visited = set()
        count = 0

        for node in graph:
            if node not in visited:
                dfs(node)
                count += 1

        return count

    graph = {
        0: [1],
        1: [0],
        2: [3],
        3: [2],
        4: []
    }

    print(count_connected_components(graph))  # Output: 3
    ```

### Additional Questions and Solutions

Here are additional questions covering various aspects of data structures and algorithms:

91. **Implement a stack using a list.**

    ```python
    class Stack:
        def __init__(self):
            self.stack = []

        def push(self, item):
            self.stack.append(item)

        def pop(self):
            if self.is_empty():
                raise IndexError("Pop from empty stack")
            return self.stack.pop()

        def peek(self):
            if self.is_empty():
                raise IndexError("Peek from empty stack")
            return self.stack[-1]

        def is_empty(self):
            return len(self.stack) == 0

    stack = Stack()
    stack.push(1)
    stack.push(2)
    print(stack.peek())  # Output: 2
    print(stack.pop())  # Output: 2
    ```

92. **Implement a queue using a list.**

    ```python
    class Queue:
        def __init__(self):
            self.queue = []

        def enqueue(self, item):
            self.queue.append(item)

        def dequeue(self):
            if self.is_empty():
                raise IndexError("Dequeue from empty queue")
            return

 self.queue.pop(0)

        def is_empty(self):
            return len(self.queue) == 0

    queue = Queue()
    queue.enqueue(1)
    queue.enqueue(2)
    print(queue.dequeue())  # Output: 1
    ```

93. **Implement a doubly linked list.**

    ```python
    class Node:
        def __init__(self, value):
            self.value = value
            self.next = None
            self.prev = None

    class DoublyLinkedList:
        def __init__(self):
            self.head = None
            self.tail = None

        def append(self, value):
            new_node = Node(value)
            if self.head is None:
                self.head = self.tail = new_node
            else:
                self.tail.next = new_node
                new_node.prev = self.tail
                self.tail = new_node

        def display(self):
            node = self.head
            while node:
                print(node.value, end=" ")
                node = node.next
            print()

    dll = DoublyLinkedList()
    dll.append(1)
    dll.append(2)
    dll.display()  # Output: 1 2
    ```

94. **Implement a binary search tree (BST).**

    ```python
    class TreeNode:
        def __init__(self, value):
            self.value = value
            self.left = None
            self.right = None

    class BinarySearchTree:
        def __init__(self):
            self.root = None

        def insert(self, value):
            if self.root is None:
                self.root = TreeNode(value)
            else:
                self._insert(self.root, value)

        def _insert(self, node, value):
            if value < node.value:
                if node.left is None:
                    node.left = TreeNode(value)
                else:
                    self._insert(node.left, value)
            else:
                if node.right is None:
                    node.right = TreeNode(value)
                else:
                    self._insert(node.right, value)

        def search(self, value):
            return self._search(self.root, value)

        def _search(self, node, value):
            if node is None:
                return False
            if node.value == value:
                return True
            elif value < node.value:
                return self._search(node.left, value)
            else:
                return self._search(node.right, value)

    bst = BinarySearchTree()
    bst.insert(5)
    bst.insert(3)
    bst.insert(7)
    print(bst.search(3))  # Output: True
    ```

95. **Check if a string is a palindrome.**

    ```python
    def is_palindrome(s):
        return s == s[::-1]

    print(is_palindrome("racecar"))  # Output: True
    print(is_palindrome("hello"))    # Output: False
    ```

96. **Reverse a string.**

    ```python
    def reverse_string(s):
        return s[::-1]

    print(reverse_string("hello"))  # Output: "olleh"
    ```

97. **Find the largest prime factor of a number.**

    ```python
    def largest_prime_factor(n):
        factor = 2
        while factor * factor <= n:
            if n % factor:
                factor += 1
            else:
                n //= factor
        return n

    print(largest_prime_factor(56))  # Output: 7
    ```

98. **Find the nth Fibonacci number.**

    ```python
    def fibonacci(n):
        a, b = 0, 1
        for _ in range(n):
            a, b = b, a + b
        return a

    print(fibonacci(10))  # Output: 55
    ```

99. **Generate a list of prime numbers up to n using the Sieve of Eratosthenes.**

    ```python
    def sieve_of_eratosthenes(n):
        primes = []
        sieve = [True] * (n + 1)
        for p in range(2, n + 1):
            if sieve[p]:
                primes.append(p)
                for multiple in range(p * p, n + 1, p):
                    sieve[multiple] = False
        return primes

    print(sieve_of_eratosthenes(30))  # Output: [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]
    ```

100. **Find the Greatest Common Divisor (GCD) of two numbers using the Euclidean algorithm.**

    ```python
    def gcd(a, b):
        while b:
            a, b = b, a % b
        return a

    print(gcd(54, 24))  # Output: 6
    ```

### More Questions to Follow...
